Server:
index.js:
// server/index.js

import express from "express";
import cors from "cors";
import crypto from "crypto";
import { loadJSON, saveJSON } from "./memory.js";
import { executeAgent } from "./executor.js";
import { calculateConfidence } from "./audit.js";

const app = express();
const PORT = process.env.PORT || 3000;
const MEMORY_FILE = "./memory.json";

app.use(cors());
app.use(express.json({ limit: "1mb" }));

// ----------------------------------------
// Logging Middleware
// ----------------------------------------
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  next();
});

// ----------------------------------------
// Health Check
// ----------------------------------------
app.get("/health", (req, res) => {
  res.json({
    status: "healthy",
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// ----------------------------------------
// Chat Endpoint
// ----------------------------------------
app.post("/chat", async (req, res) => {
  const startTime = Date.now();

  try {
    let { message, conversationId } = req.body;

    if (!message || typeof message !== "string") {
      return res.status(400).json({ error: "Missing or invalid message" });
    }

    if (message.length > 1000) {
      return res.status(400).json({
        error: "Message too long (max 1000 characters)"
      });
    }

    console.log("\n" + "=".repeat(60));
    console.log("üë§ USER:", message);

    // ----------------------------------------
    // Load Memory
    // ----------------------------------------
    const memory = loadJSON(MEMORY_FILE, { conversations: {} });
    const id = conversationId || crypto.randomUUID();

    memory.conversations[id] ??= [];
    const convo = memory.conversations[id];

    // Save user message
    convo.push({
      role: "user",
      content: message,
      timestamp: new Date().toISOString()
    });

    // ----------------------------------------
    // Preprocess message: detect file paths
    // ----------------------------------------
    function extractPath(text) {
      const match = text.match(/[A-Za-z]:[\\/]{1,2}[^?\s]+/);
      return match ? match[0] : null;
    }

    if (/scan\s+[A-Za-z]:[\\/]/i.test(message)) {
      const path = extractPath(message);
      if (path) {
        message = path;
        console.log("üõ† Detected file scan path:", message);
      }
    }

    // ----------------------------------------
    // Execute Agent
    // ----------------------------------------
    const result = await executeAgent(message, convo);

    const reply = result.reply;
    const stateGraph = result.stateGraph;

    if (!reply) {
      throw new Error("Executor returned no reply");
    }

    // ----------------------------------------
    // Confidence Calculation
    // ----------------------------------------
    const confidence = calculateConfidence(stateGraph);

    // Save assistant reply
    convo.push({
      role: "assistant",
      content: reply,
      timestamp: new Date().toISOString(),
      confidence
    });

    saveJSON(MEMORY_FILE, memory);

    const elapsed = Date.now() - startTime;

    console.log("\nüìä SUMMARY");
    console.log("Steps:", stateGraph.length);
    console.log("Tool Used:", result.tool || "none");
    console.log("Confidence:", (confidence * 100).toFixed(1) + "%");
    console.log("Time:", elapsed + "ms");
    console.log("=".repeat(60) + "\n");

    // ----------------------------------------
    // Response
    // ----------------------------------------
    res.json({
      reply,
      stateGraph,
      tool: result.tool,
      data: result.data,
      success: result.success,
      confidence,
      conversationId: id,
      metadata: {
        steps: stateGraph.length,
        executionTime: elapsed
      }
    });

  } catch (err) {
    console.error("‚ùå CHAT ERROR:", err);

    res.status(500).json({
      error: "Internal server error",
      message: err.message
    });
  }
});

// ----------------------------------------
// Conversation APIs
// ----------------------------------------
app.get("/conversation/:id", (req, res) => {
  const memory = loadJSON(MEMORY_FILE, { conversations: {} });
  const conversation = memory.conversations[req.params.id];

  if (!conversation) {
    return res.status(404).json({ error: "Conversation not found" });
  }

  res.json({
    conversationId: req.params.id,
    messages: conversation
  });
});

app.get("/conversations", (req, res) => {
  const memory = loadJSON(MEMORY_FILE, { conversations: {} });
  const conversations = Object.entries(memory.conversations).map(
    ([id, messages]) => ({
      id,
      messageCount: messages.length,
      lastMessage: messages[messages.length - 1]?.timestamp,
      preview: messages[0]?.content.slice(0, 50)
    })
  );
  res.json({ conversations });
});

app.delete("/conversation/:id", (req, res) => {
  const memory = loadJSON(MEMORY_FILE, { conversations: {} });
  if (!memory.conversations[req.params.id]) {
    return res.status(404).json({ error: "Conversation not found" });
  }
  delete memory.conversations[req.params.id];
  saveJSON(MEMORY_FILE, memory);
  res.json({ success: true });
});

// ----------------------------------------
// Start Server
// ----------------------------------------
app.listen(PORT, () => {
  console.log("\n" + "=".repeat(60));
  console.log("ü§ñ AI AGENT SERVER STARTED");
  console.log(`üì° http://localhost:${PORT}`);
  console.log("=".repeat(60) + "\n");
});

process.on("SIGINT", () => {
  console.log("\nüëã Shutting down...");
  process.exit(0);
});



audit.js:
export function detectContradictions(stateGraph, newOutput) {
  if (!newOutput) return [];

  const newStr =
    typeof newOutput === "string"
      ? newOutput
      : JSON.stringify(newOutput);

  const last = stateGraph[stateGraph.length - 1];

  if (!last) return [];

  const prevStr =
    typeof last.output === "string"
      ? last.output
      : JSON.stringify(last.output);

  if (prevStr === newStr) return [];

  if (prevStr && newStr && prevStr !== newStr) {
    return ["Potential contradiction detected"];
  }

  return [];
}

export function calculateConfidence(stateGraph) {
  let score = 0.5;

  const usedFinance = stateGraph.some(s => s.tool === "finance");
  const usedSearch = stateGraph.some(s => s.tool === "search");
  const contradictions = stateGraph.flatMap(s => s.contradictions || []);
  const citationMiss = stateGraph.flatMap(s => s.citationMiss || []);

  if (usedFinance) score += 0.25;
  if (usedSearch) score += 0.15;
  if (contradictions.length > 0) score -= 0.2;
  if (citationMiss.length > 0) score -= 0.2;

  return Math.min(Math.max(score, 0.1), 0.95);
}



executor.js:
// server/executor.js
import { plan } from "./planner.js";
import { TOOLS } from "./tools/index.js";
import { detectContradictions } from "./audit.js";

const GREETINGS = ["hi", "hey", "hello", "yo", "sup"];

/**
 * Preprocess user message based on tool context
 */
function preprocessInput(toolName, message) {
  if (toolName === "file") {
    // Extract Windows-style paths (e://testFolder or C:\Users\‚Ä¶)
    const match = message.match(/[A-Za-z]:[\\/]{1,2}[^?\s]+/);
    return match ? match[0] : message;
  }

  if (toolName === "finance") {
    // Extract ticker symbols like $AAPL or plain uppercase words
    const tickers = message.match(/\$?[A-Z]{2,5}/g);
    return tickers || message;
  }

  if (toolName === "calculator") {
    // Strip unnecessary words, keep math expressions
    return message.replace(/[^\d\+\-\*\/\(\)\.\s]/g, "");
  }

  if (toolName === "search") {
    return message; // leave full query for search tool
  }

  // Default: no preprocessing
  return message;
}

export async function executeAgent(message, conversationHistory) {
  const stateGraph = [];
  const toolUsage = {};
  let lastHash = null;

  const normalized = message.trim().toLowerCase();
  if (GREETINGS.includes(normalized) || normalized.length <= 3) {
    return {
      reply: `Hello! How can I help you today?`,
      stateGraph: [
        {
          step: 1,
          tool: "llm",
          input: message,
          output: {
            success: true,
            data: { text: "Hello! How can I help you today?" },
            final: true,
            output: "Hello! How can I help you today?"
          },
          contradictions: [],
          final: true
        }
      ],
      tool: "llm",
      data: { text: "Hello! How can I help you today?" },
      success: true
    };
  }

  while (true) {
    // Decide which tool to use
    const decision = await plan({ message, stateGraph, conversationHistory });
    if (!decision || decision.tool === "done") return finalize(stateGraph);

    const toolName = decision.tool;
    if (!TOOLS[toolName]) return finalize(stateGraph, `Unknown tool: ${toolName}`);

    toolUsage[toolName] = (toolUsage[toolName] || 0) + 1;
    if (toolUsage[toolName] > 3) return finalize(stateGraph, "Tool budget exceeded.");

    // Preprocess input for the tool
    const toolInput = preprocessInput(toolName, message);

    // Execute the tool
    let result = await TOOLS[toolName].execute(toolInput);

    // -------------------------------
    // Summarize search results
    // -------------------------------
    if (toolName === "search" && Array.isArray(result?.data?.results)) {
      const summaries = result.data.results.map(r => `${r.title}: ${r.snippet}`).join("\n");
      result.data.text = `Top search results:\n${summaries}`;
      result.final = true;
    }

    // -------------------------------
    // Summarize finance results
    // -------------------------------
    if (toolName === "finance" && Array.isArray(result?.data?.stocks)) {
      const summaries = result.data.stocks
        .map(s => `${s.symbol}: ${s.price} ${s.currency} (${s.change_percent}%)`)
        .join("\n");
      result.data.text = `Stock info:\n${summaries}`;
      result.final = true;
    }

    // Detect contradictions
    const contradictions = detectContradictions(stateGraph, result);

    // Append node to stateGraph
    const node = {
      step: stateGraph.length + 1,
      tool: toolName,
      input: toolInput,
      output: result,
      contradictions,
      final: result?.final || false
    };
    stateGraph.push(node);

    // Stop if this step is final
    if (result?.final) return finalize(stateGraph);

    // Stop if no new data
    const currentHash = JSON.stringify(result?.data || {});
    if (currentHash === lastHash) return finalize(stateGraph, "No new information gained.");

    lastHash = currentHash;
  }
}

function finalize(stateGraph, fallbackMessage = null) {
  const last = stateGraph[stateGraph.length - 1];
  return {
    reply:
      fallbackMessage ||
      last?.output?.error ||
      last?.output?.data?.text ||
      "Task completed.",
    stateGraph,
    tool: last?.tool,
    data: last?.output?.data,
    success: last?.output?.success
  };
}



memory.js:
import fs from "fs";
import path from "path";

export function loadJSON(filePath, defaultValue = {}) {
  try {
    const absolutePath = path.resolve(filePath);

    if (!fs.existsSync(absolutePath)) {
      return defaultValue;
    }

    const raw = fs.readFileSync(absolutePath, "utf-8");
    return JSON.parse(raw);
  } catch (err) {
    console.error("Error loading JSON:", err.message);
    return defaultValue;
  }
}

export function saveJSON(filePath, data) {
  try {
    const absolutePath = path.resolve(filePath);
    fs.writeFileSync(absolutePath, JSON.stringify(data, null, 2));
  } catch (err) {
    console.error("Error saving JSON:", err.message);
  }
}



planner.js:
// server/planner.js
import fetch from "node-fetch";
import { TOOLS } from "./tools/index.js";

/**
 * Dynamic LLM-driven Planner
 * - Chooses tool based on user message, recent conversation, and stateGraph
 * - Returns structured JSON: { tool, reason }
 * - Validates tool exists in TOOLS
 */
const GREETINGS = ["hi", "hey", "hello", "yo", "sup"];

export async function plan({ message, stateGraph, conversationHistory }) {
  const normalized = message.trim().toLowerCase();

  // Simple greeting fallback
  if (GREETINGS.includes(normalized) || normalized.length <= 3) {
    return { tool: "llm", reason: "Simple greeting / small input" };
  }

  const lastNode = stateGraph[stateGraph.length - 1];
  if (lastNode?.final) return { tool: "done", reason: "Final step reached" };

  const recentHistory = conversationHistory
    .slice(-5)
    .map(m => `${m.role}: ${m.content}`)
    .join("\n");

  const prompt = `
You are an assistant's tool selection AI.
Available tools: ${Object.keys(TOOLS).join(", ")}

Rules:
- Pure math ‚Üí calculator
- Stocks / market / ticker ‚Üí finance
- Local files ‚Üí file
- Internet info ‚Üí search
- General reasoning ‚Üí llm
- If fully answered ‚Üí done

Return STRICT JSON: {
  "tool": "tool_name",
  "reason": "short explanation"
}

Conversation History:
${recentHistory}

StateGraph: ${JSON.stringify(stateGraph)}

User Request: ${message}
`;

  try {
    const res = await fetch("http://localhost:11434/api/generate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: "mat-llm:latest",
        prompt,
        stream: false,
        options: { temperature: 0 }
      })
    });

    const data = await res.json();
    const text = data.response?.trim();

    let parsed;
    try {
      parsed = JSON.parse(text);
    } catch {
      parsed = { tool: "llm", reason: "Planner fallback (JSON parse error)" };
    }

    if (!TOOLS[parsed.tool]) {
      return { tool: "llm", reason: "Fallback to LLM for unknown tool" };
    }

    return parsed;
  } catch (err) {
    console.error("Planner error:", err);
    return { tool: "llm", reason: "Planner fallback (fetch error)" };
  }
}



calculator.js:
// server/tools/calculator.js
// Deterministic safe calculator tool
// Structured return system

function sanitizeExpression(input) {
  const match = input.match(/[-+*/().\d\s]+/);
  if (!match) return null;

  const expr = match[0];

  if (!/^[\d+\-*/().\s]+$/.test(expr)) return null;

  return expr;
}

function evaluateExpression(expr) {
  try {
    const result = Function(`"use strict"; return (${expr})`)();

    if (typeof result !== "number" || !isFinite(result)) {
      return { error: "Invalid calculation result" };
    }

    return { result };
  } catch {
    return { error: "Invalid mathematical expression" };
  }
}

export function calculator(message) {
  const expr = sanitizeExpression(message);

  if (!expr) {
    return {
      tool: "calculator",
      success: false,
      final: true,
      error: "No valid math expression found"
    };
  }

  const evaluation = evaluateExpression(expr);

  if (evaluation.error) {
    return {
      tool: "calculator",
      success: false,
      final: true,
      error: evaluation.error
    };
  }

  return {
    tool: "calculator",
    success: true,
    final: true,
    data: {
      expression: expr,
      result: evaluation.result
    }
  };
}


 file.js:
// server/tools/file.js
// File system tool (sandboxed)

import fs from "fs/promises";
import path from "path";

const SANDBOX_ROOT = "E:/sandbox"; // adjust your sandbox path

/**
 * Ensure the given path is inside sandbox
 */
function sanitizePath(requestedPath) {
  const resolved = path.resolve(SANDBOX_ROOT, requestedPath);
  if (!resolved.startsWith(SANDBOX_ROOT)) throw new Error("Access outside sandbox denied");
  return resolved;
}

export async function file(request) {
  try {
    const sanitizedPath = sanitizePath(request);

    const stat = await fs.stat(sanitizedPath);
    let data = {};

    if (stat.isDirectory()) {
      const items = await fs.readdir(sanitizedPath, { withFileTypes: true });
      data.items = items.map(i => ({
        name: i.name,
        type: i.isDirectory() ? "folder" : "file"
      }));
      data.text = `Folder contents:\n${data.items.map(i => `${i.type}: ${i.name}`).join("\n")}`;
    } else if (stat.isFile()) {
      const content = await fs.readFile(sanitizedPath, "utf-8");
      data.items = [{ name: path.basename(sanitizedPath), type: "file", size: stat.size }];
      data.text = `File: ${path.basename(sanitizedPath)} (${stat.size} bytes)\nPreview:\n${content.slice(0, 500)}`;
    } else {
      data.text = "Unknown file type.";
    }

    return {
      tool: "file",
      success: true,
      final: true,
      data
    };
  } catch (err) {
    return {
      tool: "file",
      success: false,
      final: true,
      error: err.message
    };
  }
}


finance.js: 
// server/tools/search.js
// Multi-engine web search tool (Google, DuckDuckGo, Brave, Wikipedia)

import { safeFetch } from "../utils/fetch.js";
import { CONFIG } from "../utils/config.js";
import { loadJSON, saveJSON } from "../memory.js";

const SEARCH_CACHE_FILE = "./search_cache.json";

/**
 * Normalize and sanitize search query for caching
 */
function extractTopic(text) {
  return text
    .toLowerCase()
    .replace(/please|could you|would you|check again|verify/gi, "")
    .replace(/[^a-z0-9\s]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 100);
}

/**
 * Fetch Wikipedia summary
 */
async function fetchWikipedia(query) {
  try {
    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`;
    const data = await safeFetch(url);
    if (data?.extract) {
      return { title: data.title, snippet: data.extract, url: `https://en.wikipedia.org/wiki/${data.title}` };
    }
  } catch {}
  return null;
}

/**
 * Fetch DuckDuckGo instant answer
 */
async function fetchDuckDuckGo(query) {
  try {
    const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1`;
    const data = await safeFetch(url);
    const results = [];
    if (data?.RelatedTopics) {
      for (const item of data.RelatedTopics.slice(0, 5)) {
        if (item.Text && item.FirstURL) {
          results.push({ title: item.Text, snippet: item.Text, url: item.FirstURL });
        }
      }
    }
    return results;
  } catch {
    return [];
  }
}

/**
 * Fetch Google results via SERPAPI
 */
async function fetchGoogle(query) {
  if (!CONFIG.SERPAPI_KEY) return [];
  try {
    const url = `https://serpapi.com/search.json?q=${encodeURIComponent(query)}&api_key=${CONFIG.SERPAPI_KEY}`;
    const data = await safeFetch(url);
    if (!data?.organic_results) return [];
    return data.organic_results.slice(0, 5).map(r => ({
      title: r.title,
      snippet: r.snippet || "",
      url: r.link
    }));
  } catch {
    return [];
  }
}

/**
 * Main search tool
 */
export async function search(query, forceRefresh = false) {
  const topic = extractTopic(query);
  const cache = loadJSON(SEARCH_CACHE_FILE, {});

  if (!forceRefresh && cache[topic]) {
    return {
      tool: "search",
      success: true,
      final: true,
      data: { cached: true, results: cache[topic].results, text: cache[topic].text }
    };
  }

  try {
    const results = [];

    // Wikipedia
    const wiki = await fetchWikipedia(query);
    if (wiki) results.push(wiki);

    // DuckDuckGo
    const ddgResults = await fetchDuckDuckGo(query);
    results.push(...ddgResults);

    // Google
    const googleResults = await fetchGoogle(query);
    results.push(...googleResults);

    const summaryText = results.map(r => `${r.title}: ${r.snippet}`).join("\n");

    // Save cache
    cache[topic] = { timestamp: Date.now(), results, text: summaryText };
    saveJSON(SEARCH_CACHE_FILE, cache);

    return { tool: "search", success: true, final: true, data: { cached: false, results, text: summaryText } };
  } catch (err) {
    return { tool: "search", success: false, final: true, error: err.message };
  }
}



server/tools/index.js: 
// server/tools/index.js

import { calculator } from "./calculator.js";
import { finance } from "./finance.js";
import { search } from "./search.js";
import { file } from "./file.js";
import { llm } from "./llm.js";

export const TOOLS = {
  calculator: { execute: calculator },
  finance: { execute: finance },
  search: { execute: search },
  file: { execute: file },
  llm: { execute: llm }   // ‚Üê THIS IS THE FIX
};



search.js: ////////////////////////////////////
// server/tools/search.js
import { safeFetch } from "../utils/fetch.js";
import { CONFIG } from "../utils/config.js";
import { loadJSON, saveJSON } from "../memory.js";

const SEARCH_CACHE_FILE = "./search_cache.json";

/**
 * Extract normalized search topic
 */
function extractTopic(text) {
  return text
    .toLowerCase()
    .replace(/please|could you|would you|check again|verify/gi, "")
    .replace(/[^a-z0-9\s]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 100);
}

/**
 * Fetch SERPAPI results
 */
async function fetchSERP(query, numResults = 5) {
  const url = `https://serpapi.com/search.json?q=${encodeURIComponent(
    query
  )}&num=${numResults}&api_key=${CONFIG.SERPAPI_KEY}`;

  const data = await safeFetch(url);
  if (!data || !data.organic_results) return [];
  return data.organic_results.slice(0, numResults).map(r => ({
    title: r.title,
    snippet: r.snippet || "",
    url: r.link
  }));
}

/**
 * Placeholder DuckDuckGo search
 */
async function fetchDuckDuckGo(query, numResults = 5) {
  const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(
    query
  )}&format=json&t=assistant&no_redirect=1`;

  const data = await safeFetch(url);
  if (!data || !data.RelatedTopics) return [];
  return data.RelatedTopics.slice(0, numResults).map(r => ({
    title: r.Text || r.FirstURL || "DuckDuckGo Result",
    snippet: r.Text || "",
    url: r.FirstURL || ""
  }));
}

/**
 * Main search tool
 */
export async function search(query, forceRefresh = false) {
  if (!CONFIG.SERPAPI_KEY) {
    return {
      tool: "search",
      success: false,
      final: true,
      error: "Missing SERPAPI key"
    };
  }

  const cache = loadJSON(SEARCH_CACHE_FILE, {});
  const topic = extractTopic(query);

  if (!forceRefresh && cache[topic]?.results?.length) {
    return {
      tool: "search",
      success: true,
      final: true,
      data: { cached: true, results: cache[topic].results }
    };
  }

  try {
    // Fetch multiple sources
    const [googleResults, duckResults] = await Promise.all([
      fetchSERP(topic, 5),
      fetchDuckDuckGo(topic, 5)
    ]);

    const results = [...googleResults, ...duckResults];

    // Cache results
    if (results.length > 0) {
      cache[topic] = { timestamp: Date.now(), results };
      saveJSON(SEARCH_CACHE_FILE, cache);
    }

    // Summarize for assistant
    const summary = results.map(r => `${r.title}: ${r.snippet}`).join("\n");

    return {
      tool: "search",
      success: true,
      final: true,
      data: { cached: false, results, text: `Top search results:\n${summary}` }
    };
  } catch (err) {
    console.error("Search error:", err);
    return {
      tool: "search",
      success: false,
      final: true,
      error: "Search request failed"
    };
  }
}



config.js: ////////////////////////////////////
// server/utils/config.js
import 'dotenv/config';

/**
 * Centralized configuration with validation
 */

const requiredEnvVars = {
  FMP_API_KEY: process.env.FMP_API_KEY,
  SERPAPI_KEY: process.env.SERPAPI_KEY
};

const warnings = [];

// Validate required environment variables
for (const [key, value] of Object.entries(requiredEnvVars)) {
  if (!value) {
    warnings.push(`‚ö†Ô∏è  ${key} not set - ${key.toLowerCase().includes('fmp') ? 'finance' : 'search'} features will be unavailable`);
  }
}

export const CONFIG = {
  // Server
  PORT: process.env.PORT || 3000,
  NODE_ENV: process.env.NODE_ENV || 'development',

  // LLM
  LLM_MODEL: process.env.LLM_MODEL || 'llama3.2',
  LLM_API_URL: process.env.LLM_API_URL || 'http://localhost:11434',

  // Agent Limits
  MAX_STEPS: parseInt(process.env.MAX_STEPS || '3'),
  TOOL_BUDGET_SEARCH: parseInt(process.env.TOOL_BUDGET_SEARCH || '3'),
  TOOL_BUDGET_FINANCE: parseInt(process.env.TOOL_BUDGET_FINANCE || '2'),
  TOOL_BUDGET_CALCULATOR: parseInt(process.env.TOOL_BUDGET_CALCULATOR || '1'),

  // API Keys
  FMP_API_KEY: process.env.FMP_API_KEY,
  SERPAPI_KEY: process.env.SERPAPI_KEY,

  // Critical Tools (won't fallback to LLM if these fail)
  CRITICAL_TOOLS: (process.env.CRITICAL_TOOLS || 'finance').split(','),

  // Cache
  SEARCH_CACHE_TTL: parseInt(process.env.SEARCH_CACHE_TTL || '3600000'), // 1 hour

  // Validation
  isValid() {
    return this.FMP_API_KEY && this.SERPAPI_KEY;
  },

  getWarnings() {
    return warnings;
  }
};

// Log warnings on startup
if (warnings.length > 0) {
  console.warn('\n' + '='.repeat(60));
  console.warn('‚ö†Ô∏è  CONFIGURATION WARNINGS:');
  warnings.forEach(w => console.warn(w));
  console.warn('='.repeat(60) + '\n');
}

// Validate LLM settings
if (!process.env.LLM_MODEL) {
  console.info(`‚ÑπÔ∏è  Using default LLM model: ${CONFIG.LLM_MODEL}`);
}



fetch.js: ////////////////////////////////////
import fetch from "node-fetch";

export async function safeFetch(url, options = {}) {
  try {
    const res = await fetch(url, options);

    if (!res.ok) {
      console.error(`Fetch error: HTTP ${res.status}`);
      return null;
    }

    const contentType = res.headers.get("content-type") || "";

    if (contentType.includes("application/json")) {
      return await res.json();
    }

    const text = await res.text();

    try {
      return JSON.parse(text);
    } catch {
      return null;
    }
  } catch (err) {
    console.error("Fetch error:", err.message);
    return null;
  }
}




