

======================================================================
FILE: D:/local-llm-ui/server/tools/search.js
======================================================================

// server/tools/search.js (ENHANCED - Yandex added as 4th source)
import { safeFetch } from "../utils/fetch.js";
import { CONFIG } from "../utils/config.js";
import { loadJSON, saveJSON } from "../memory.js";

const CACHE_FILE = "./search_cache.json";
const CACHE_TTL = 3600000; // 1 hour

function normalizeQuery(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

function calculateSimilarity(str1, str2) {
  const set1 = new Set(str1.toLowerCase().split(/\s+/));
  const set2 = new Set(str2.toLowerCase().split(/\s+/));
  
  const intersection = new Set([...set1].filter(x => set2.has(x)));
  const union = new Set([...set1, ...set2]);
  
  return intersection.size / union.size;
}

function deduplicateResults(results) {
  const seen = new Set();
  const deduplicated = [];

  for (const result of results) {
    if (seen.has(result.url)) continue;
    
    const isDuplicate = deduplicated.some(existing => {
      const titleSim = calculateSimilarity(result.title, existing.title);
      const snippetSim = calculateSimilarity(result.snippet, existing.snippet);
      return titleSim > 0.8 || snippetSim > 0.9;
    });

    if (!isDuplicate) {
      seen.add(result.url);
      deduplicated.push(result);
    }
  }

  return deduplicated;
}

function scoreRelevance(result, query) {
  const queryTerms = query.toLowerCase().split(/\s+/);
  const titleLower = result.title.toLowerCase();
  const snippetLower = result.snippet.toLowerCase();
  
  let score = 0;
  
  for (const term of queryTerms) {
    if (titleLower.includes(term)) score += 3;
    if (snippetLower.includes(term)) score += 1;
  }
  
  if (titleLower.includes(query.toLowerCase())) score += 10;
  if (snippetLower.includes(query.toLowerCase())) score += 5;
  
  const credibleDomains = [
    'wikipedia.org', 'britannica.com', 'edu', 'gov',
    'reuters.com', 'bbc.com', 'cnn.com', 'nytimes.com'
  ];
  
  if (credibleDomains.some(domain => result.url.includes(domain))) {
    score += 2;
  }
  
  return score;
}

// Wikipedia summary fetch
async function fetchWikipedia(query) {
  try {
    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`;
    const data = await safeFetch(url);

    if (!data || !data.extract) return [];

    return [
      {
        title: data.title || query,
        snippet: data.extract,
        url: `https://en.wikipedia.org/wiki/${encodeURIComponent(data.title || query)}`,
        source: "Wikipedia"
      }
    ];
  } catch (err) {
    console.warn("Wikipedia fetch failed:", err.message);
    return [];
  }
}

// DuckDuckGo Instant Answer API
async function fetchDuckDuckGo(query) {
  try {
    const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json`;
    const data = await safeFetch(url);

    if (!data || !data.RelatedTopics) return [];

    const results = data.RelatedTopics
      .filter(r => r.Text && r.FirstURL)
      .slice(0, 5)
      .map(r => ({
        title: r.Text.split(" - ")[0] || r.Text,
        snippet: r.Text,
        url: r.FirstURL,
        source: "DuckDuckGo"
      }));
    
    if (data.Abstract && data.AbstractURL) {
      results.unshift({
        title: data.Heading || query,
        snippet: data.Abstract,
        url: data.AbstractURL,
        source: "DuckDuckGo"
      });
    }

    return results;
  } catch (err) {
    console.warn("DuckDuckGo fetch failed:", err.message);
    return [];
  }
}

// Google / SerpAPI search
async function fetchGoogle(query) {
  try {
    const apiKey = CONFIG.SERPAPI_KEY;
    if (!apiKey) {
      console.warn("SerpAPI key not configured");
      return [];
    }

    const url = `https://serpapi.com/search.json?q=${encodeURIComponent(query)}&api_key=${apiKey}&num=10`;
    const data = await safeFetch(url);

    if (!data || !data.organic_results) return [];

    return data.organic_results.slice(0, 10).map(r => ({
      title: r.title || query,
      snippet: r.snippet || "",
      url: r.link || "",
      source: "Google"
    }));
  } catch (err) {
    console.warn("Google/SerpAPI fetch failed:", err.message);
    return [];
  }
}

// NEW: Yandex search via SerpAPI
async function fetchYandex(query) {
  try {
    const apiKey = CONFIG.SERPAPI_KEY;
    if (!apiKey) {
      console.warn("SerpAPI key not configured for Yandex");
      return [];
    }

    const url = `https://serpapi.com/search.json?engine=yandex&text=${encodeURIComponent(query)}&api_key=${apiKey}`;
    const data = await safeFetch(url);

    if (!data || !data.organic_results) return [];

    return data.organic_results.slice(0, 8).map(r => ({
      title: r.title || query,
      snippet: r.snippet || r.description || "",
      url: r.link || "",
      source: "Yandex"
    }));
  } catch (err) {
    console.warn("Yandex/SerpAPI fetch failed:", err.message);
    return [];
  }
}

// Enhanced search with 4 sources including Yandex
export async function search(query) {
  console.log("üîé Search query:", query);
  
  const normalizedQuery = normalizeQuery(query);

  // Check cache
  const cache = loadJSON(CACHE_FILE, {});
  const cached = cache[normalizedQuery];
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log("üì¶ Using cached result");
    return {
      tool: "search",
      success: true,
      final: true,
      data: cached.data,
      reasoning: "Retrieved from cache"
    };
  }

  // Fetch from FOUR sources in parallel (Wikipedia, DuckDuckGo, Google, Yandex)
  console.log("üåê Fetching from 4 sources (Wikipedia, DuckDuckGo, Google, Yandex)...");
  const [wiki, ddg, google, yandex] = await Promise.all([
    fetchWikipedia(query),
    fetchDuckDuckGo(query),
    fetchGoogle(query),
    fetchYandex(query)
  ]);

  console.log(`üìä Results: Wikipedia(${wiki.length}), DuckDuckGo(${ddg.length}), Google(${google.length}), Yandex(${yandex.length})`);

  // Combine and deduplicate
  let allResults = [...wiki, ...ddg, ...google, ...yandex];
  allResults = deduplicateResults(allResults);

  // Score and sort by relevance
  allResults.forEach(result => {
    result.relevanceScore = scoreRelevance(result, query);
  });

  allResults.sort((a, b) => b.relevanceScore - a.relevanceScore);

  // Take top results
  const topResults = allResults.slice(0, 10);

  // Generate summary text
  const summary = topResults.length > 0
    ? topResults
        .map((r, i) => `${i + 1}. ${r.title}\n   ${r.snippet}\n   Source: ${r.source} | ${r.url}`)
        .join("\n\n")
    : "No reliable results were found for this query from the sources I checked.";

  const data = {
    results: topResults,
    text: summary,
    totalSources: [wiki, ddg, google, yandex].filter(arr => arr.length > 0).length,
    query: query,
    normalizedQuery: normalizedQuery
  };

  // Cache the result
  cache[normalizedQuery] = {
    data,
    timestamp: Date.now()
  };
  saveJSON(CACHE_FILE, cache);

  console.log(`‚úÖ Returning ${topResults.length} deduplicated results from ${data.totalSources} sources`);

  return {
    tool: "search",
    success: true,
    final: true,
    data,
    reasoning: `Searched ${data.totalSources} sources (Wikipedia, DuckDuckGo, Google, Yandex), found ${topResults.length} relevant results`
  };
}

export function extractTopic(text) {
  return normalizeQuery(text);
}



======================================================================
FILE: D:/local-llm-ui/server/tools/review.js
======================================================================

// server/tools/review.js
// COMPLETE FIX #4, #5: Review tool that actually reads files (no hallucination)

import fs from "fs/promises";
import path from "path";
import { llm } from "./llm.js";

const SANDBOX_ROOTS = [
  path.resolve("D:/local-llm-ui"),
  path.resolve("E:/testFolder")
];

const MAX_FILE_SIZE = 200 * 1024; // 200KB

function isPathAllowed(resolvedPath) {
  return SANDBOX_ROOTS.some(root => resolvedPath.startsWith(root));
}

// Extract file path from natural language
function extractFilePath(query) {
  const lower = query.toLowerCase();
  
  // Pattern 1: "review news.js in tools folder"
  let match = query.match(/review\s+([a-zA-Z0-9_\-\.]+)\s+in\s+(the\s+)?([a-zA-Z0-9_\-\/\s]+)/i);
  if (match) {
    const filename = match[1];
    let folder = match[3].trim();
    
    // Clean up folder path
    folder = folder.replace(/\s+folder\s*$/i, '').replace(/\s+/g, '/');
    
    return { filename, folder, fullPath: `${folder}/${filename}` };
  }
  
  // Pattern 2: "review server/tools/news.js"
  match = query.match(/review\s+([a-zA-Z0-9_\-\.\/\\]+)/i);
  if (match) {
    const fullPath = match[1].trim();
    return { fullPath };
  }
  
  // Pattern 3: Just a filename
  match = query.match(/review\s+([a-zA-Z0-9_\-\.]+)/i);
  if (match) {
    return { filename: match[1] };
  }
  
  return null;
}

// Resolve file path with sandbox validation
async function resolveFilePath(pathInfo) {
  if (!pathInfo) return null;
  
  const sandboxRoot = SANDBOX_ROOTS[0]; // Default to project root
  
  // Try direct path first
  if (pathInfo.fullPath) {
    let resolved = path.resolve(sandboxRoot, pathInfo.fullPath);
    if (isPathAllowed(resolved)) {
      try {
        await fs.access(resolved);
        return resolved;
      } catch {
        // Try without extension
        resolved = path.resolve(sandboxRoot, pathInfo.fullPath + '.js');
        if (isPathAllowed(resolved)) {
          try {
            await fs.access(resolved);
            return resolved;
          } catch {}
        }
      }
    }
  }
  
  // Try filename + folder
  if (pathInfo.filename && pathInfo.folder) {
    const resolved = path.resolve(sandboxRoot, pathInfo.folder, pathInfo.filename);
    if (isPathAllowed(resolved)) {
      try {
        await fs.access(resolved);
        return resolved;
      } catch {}
    }
  }
  
  // Try just filename (search common locations)
  if (pathInfo.filename) {
    const commonPaths = [
      path.resolve(sandboxRoot, 'server/tools', pathInfo.filename),
      path.resolve(sandboxRoot, 'server', pathInfo.filename),
      path.resolve(sandboxRoot, 'client/src', pathInfo.filename),
      path.resolve(sandboxRoot, pathInfo.filename)
    ];
    
    for (const testPath of commonPaths) {
      if (isPathAllowed(testPath)) {
        try {
          await fs.access(testPath);
          return testPath;
        } catch {}
      }
    }
  }
  
  return null;
}

export async function review(query) {
  try {
    console.log("üîç Review tool called with:", query);
    
    // Extract file path
    const pathInfo = extractFilePath(query);
    if (!pathInfo) {
      return {
        tool: "review",
        success: false,
        final: true,
        error: "Could not determine which file to review. Please specify a file path like:\n- 'review news.js in tools folder'\n- 'review server/tools/news.js'\n- 'review news.js'"
      };
    }
    
    console.log("üìÇ Extracted path info:", pathInfo);
    
    // Resolve to actual file path
    const resolvedPath = await resolveFilePath(pathInfo);
    if (!resolvedPath) {
      return {
        tool: "review",
        success: false,
        final: true,
        error: `Could not find file: ${pathInfo.filename || pathInfo.fullPath}\n\nSearched in:\n- server/tools/\n- server/\n- client/src/\n- project root\n\nPlease check the file name and path.`
      };
    }
    
    console.log("‚úÖ Resolved to:", resolvedPath);
    
    // Check file size
    const stat = await fs.stat(resolvedPath);
    if (stat.size > MAX_FILE_SIZE) {
      return {
        tool: "review",
        success: false,
        final: true,
        error: `File too large: ${Math.round(stat.size / 1024)}KB (max 200KB)\n\nPlease review smaller files or request specific sections.`
      };
    }
    
    // Read file content
    const content = await fs.readFile(resolvedPath, "utf8");
    const lines = content.split('\n').length;
    
    console.log(`üìÑ Read file: ${lines} lines, ${content.length} bytes`);
    
    // Build LLM review prompt
    const filename = path.basename(resolvedPath);
    const relativePath = path.relative("D:/local-llm-ui", resolvedPath);
    
    const prompt = `You are a senior software engineer conducting a code review.

FILE: ${relativePath}
PROJECT CONTEXT: Local LLM UI (Node.js/Express backend + React frontend)
LINES: ${lines}
SIZE: ${Math.round(content.length / 1024)}KB

TASK: Provide a structured, professional code review with:

1. **Summary** (2-3 sentences):
   - What this file does
   - How it fits into the project architecture
   - Its role and responsibilities

2. **Key Observations** (3-5 points):
   - Important design patterns used
   - Critical functionality
   - Notable implementation details

3. **Strengths** (2-3 points):
   - What's done well
   - Good practices observed

4. **Suggestions for Improvement** (3-5 points):
   - Specific, actionable improvements
   - Security considerations
   - Performance optimizations
   - Code quality enhancements

FILE CONTENT:
\`\`\`javascript
${content}
\`\`\`

IMPORTANT: 
- Be specific and reference actual code
- Provide actionable suggestions
- Keep professional tone
- Focus on substance, not style`;

    // Get LLM review
    console.log("ü§ñ Calling LLM for review...");
    const llmResponse = await llm(prompt);
    
    if (!llmResponse.success) {
      throw new Error("LLM review failed: " + (llmResponse.error || "Unknown error"));
    }
    
    const reviewText = llmResponse.data?.text || "Review could not be generated.";
    
    console.log("‚úÖ Review generated:", reviewText.slice(0, 100) + "...");
    
    // Format response
    const html = `
      <div class="review-panel">
        <div class="review-header">
          <h3>üîç Code Review: ${filename}</h3>
          <p class="review-path">üìÇ ${relativePath}</p>
          <p class="review-meta">üìè ${lines} lines ‚Ä¢ ${Math.round(content.length / 1024)}KB</p>
        </div>
        <div class="review-content">
          ${reviewText.replace(/\n\n/g, '</p><p>').replace(/^/, '<p>').replace(/$/, '</p>')}
        </div>
      </div>
      
      <style>
        .review-panel {
          background: var(--bg-tertiary);
          border: 1px solid var(--border);
          border-radius: 8px;
          padding: 1.5rem;
          margin: 1rem 0;
        }
        .review-header h3 {
          color: var(--accent);
          margin-bottom: 0.5rem;
        }
        .review-path {
          color: var(--text-secondary);
          font-family: monospace;
          font-size: 0.9rem;
          margin: 0.25rem 0;
        }
        .review-meta {
          color: var(--text-muted);
          font-size: 0.85rem;
          margin: 0.25rem 0;
        }
        .review-content {
          margin-top: 1rem;
          color: var(--text-primary);
          line-height: 1.6;
        }
        .review-content p {
          margin: 0.75rem 0;
        }
      </style>
    `;
    
    return {
      tool: "review",
      success: true,
      final: true,
      data: {
        file: filename,
        path: relativePath,
        lines,
        size: content.length,
        reviewText,
        html,
        text: `Code Review: ${filename}\n\n${reviewText}`
      },
      reasoning: `Reviewed ${filename} (${lines} lines)`
    };
    
  } catch (err) {
    console.error("‚ùå Review tool error:", err);
    return {
      tool: "review",
      success: false,
      final: true,
      error: `Review failed: ${err.message}\n\nPlease check:\n1. File path is correct\n2. File exists and is readable\n3. File is under 200KB`,
      data: {
        errorDetails: err.message
      }
    };
  }
}

