// server/tools/email.js
import { google } from "googleapis";
import { getAuthorizedClient } from "../utils/googleOAuth.js";
import { resolveContact, extractContactRef } from "./contacts.js";
import fs from "fs/promises";
import path from "path";
import { PROJECT_ROOT } from "../utils/config.js";
import { getMemory } from "../memory.js";

// FIX: Removed ^ and $ anchors â€” regex now matches email anywhere in a sentence.
const emailRegex = /[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}/i;

const subjectRegex = /subject[:\s]+([^\n]+)/i;

// FIX: "saying" body extraction now cuts off trailing noise like "with the planner"
const sayingRegex = /saying[:\s]+(.+?)(?:\s+with\s+(?:the\s+)?(?:planner|executor|subject|attachment)|$)/is;

const attachmentPatterns = [
  /with\s+(.+?\.(?:pdf|docx|xlsx|png|jpg|jpeg|txt|csv))\s+attached/gi,
  /attach(?:ing)?\s+(.+?\.(?:pdf|docx|xlsx|png|jpg|jpeg|txt|csv))/gi,
  /send\s+(?:the\s+)?(.+?\.(?:pdf|docx|xlsx|png|jpg|jpeg|txt|csv))/gi
];

/**
 * Strip markdown formatting characters that wrap email addresses.
 * e.g.  __efratimatan@gmail.com__  â†’  efratimatan@gmail.com
 *       **john@example.com**       â†’  john@example.com
 */
function stripMarkdown(text) {
  return text.replace(/[_*`~]/g, "");
}

async function parseEmailRequest(query) {
  await getMemory(); // keep memory warm; used by resolveContact

  let to      = null;
  let subject = "Message from AI Agent";
  let body    = query;

  // FIX: clean markdown before matching email
  const cleanQuery = stripMarkdown(query);

  const emailMatch = cleanQuery.match(emailRegex);
  if (emailMatch) {
    to = emailMatch[0].toLowerCase();
    console.log(`ðŸ“§ Extracted email address: ${to}`);
  } else {
    const contactRef = extractContactRef(query);
    if (contactRef) {
      const resolved = await resolveContact(contactRef);
      if (resolved?.contact?.email) {
        to = resolved.contact.email;
        console.log(`ðŸ“§ Resolved contact "${contactRef}" â†’ ${to}`);
      }
    }
  }

  // Subject
  const subjectMatch = cleanQuery.match(subjectRegex);
  if (subjectMatch) {
    subject = subjectMatch[1].trim();
  }

  // Body â€” prefer explicit "saying â€¦" clause
  const sayingMatch = query.match(sayingRegex);
  if (sayingMatch) {
    body = sayingMatch[1].trim();
  } else {
    // Fallback: text after "about <topic> saying <body>"
    const aboutSayingMatch = query.match(/about\s+.+?\s+saying\s+(.+)/is);
    if (aboutSayingMatch) {
      body = aboutSayingMatch[1].trim();
    } else {
      // Last-resort: strip routing noise from the raw query
      body = query
        .replace(/send (?:an )?email to [^\s]+/i, "")
        .replace(/with the planner/i, "")
        .replace(/subject[:\s]+[^\n]+/i, "")
        .trim();
    }
  }

  // Attachments
  const requestedAttachments = [];
  for (const pattern of attachmentPatterns) {
    let match;
    while ((match = pattern.exec(cleanQuery)) !== null) {
      requestedAttachments.push(match[1].trim());
    }
  }

  return { to, subject, body, requestedAttachments };
}

async function findAttachment(filename) {
  const searchPaths = [
    path.resolve(PROJECT_ROOT, "uploads",   filename),
    path.resolve(PROJECT_ROOT, "downloads", filename),
    path.resolve(PROJECT_ROOT,              filename)
  ];
  for (const p of searchPaths) {
    try { await fs.access(p); return p; } catch { /* try next */ }
  }
  return null;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DRAFT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function email(query) {
  try {
    const { to, subject, body, requestedAttachments } = await parseEmailRequest(query);

    if (!to) {
      return {
        tool: "email",
        success: false,
        final: true,
        error: "Could not detect recipient email address.\n\nTry:\nâ€¢ 'send email to john@example.com'\nâ€¢ 'email mom about dinner' (if mom is a saved contact)"
      };
    }

    const attachments = [];
    for (const filename of requestedAttachments) {
      const filepath = await findAttachment(filename);
      if (filepath) {
        const stat = await fs.stat(filepath);
        attachments.push({ filename: path.basename(filepath), filepath, size: stat.size });
      }
    }

    return {
      tool: "email",
      success: true,
      final: true,
      data: {
        mode: "draft",
        to, subject, body, attachments,
        pendingEmail: { to, subject, body, attachments },
        message:
          `ðŸ“§ **Email Draft:**\n\n` +
          `**To:** ${to}\n` +
          `**Subject:** ${subject}\n` +
          `**Message:**\n${body}` +
          (attachments.length > 0
            ? `\n\nðŸ“Ž **Attachments (${attachments.length}):**\n${attachments.map(a => `â€¢ ${a.filename}`).join('\n')}`
            : "") +
          `\n\nâœ… Say "send it" to confirm, or "cancel" to discard.`
      }
    };
  } catch (err) {
    console.error("Email tool error:", err);
    return { tool: "email", success: false, final: true, error: `Email operation failed: ${err.message}` };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SEND
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function sendConfirmedEmail({ to, subject, body, attachments = [] }) {
  try {
    const auth  = await getAuthorizedClient();
    const gmail = google.gmail({ version: "v1", auth });

    const raw = Buffer.from(
      [`To: ${to}`, `Subject: ${subject}`, "MIME-Version: 1.0",
       "Content-Type: text/plain; charset=utf-8", "", body].join("\n")
    )
      .toString("base64")
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=+$/, "");

    const res = await gmail.users.messages.send({ userId: "me", requestBody: { raw } });

    return {
      tool: "email", success: true, final: true,
      data: { to, subject, body, messageId: res.data.id, message: `âœ… Email sent successfully to ${to}` }
    };
  } catch (err) {
    return { tool: "email", success: false, final: true, error: `Email sending failed: ${err.message}` };
  }
}
